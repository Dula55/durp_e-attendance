{
  "rules": {
    // default: only authenticated users may read; writes are controlled more specifically below
    ".read": "auth != null",
    ".write": "false",

    "admins": {
      // only admins may read/write the admins list
      ".read": "auth != null && auth.token.admin === true",
      ".write": "auth != null && auth.token.admin === true"
    },

    "pins": {
      // authenticated users can read the active PIN; only admins can set/reset it
      ".read": "auth != null",
      ".write": "auth != null && auth.token.admin === true",
      "$pinId": {
        ".validate": "newData.hasChildren(['pin','updatedAt']) && newData.child('pin').isString() && newData.child('updatedAt').isNumber()"
      }
    },

    "attendance": {
      // Attendance is organized as: /attendance/{courseId}/{yyyy-mm-dd}/{matric}
      // - authenticated users may CREATE a record at that exact path only if it does NOT already exist (prevents duplicates)
      // - admins (auth.token.admin === true) may write/update/delete any attendance nodes
      "$courseId": {
        "$date": {
          "$matric": {
            ".read": "auth != null",
            ".write": "(
                // Admins can write/update/delete
                auth != null && auth.token.admin === true
              ) || (
                // Authenticated non-admins may create a record only if it doesn't already exist
                auth != null &&
                !data.exists() &&
                newData.exists() &&
                // validation of required fields during create
                newData.child('matric').isString() &&
                newData.child('course').isString() &&
                newData.child('date').isString() &&
                newData.child('time').isString() &&
                newData.child('name').isString() &&
                // createdAt must be numeric (timestamp)
                newData.child('createdAt').isNumber() &&
                // ensure the matric/course/date path match the payload (guard against mismatched keys)
                newData.child('matric').val() === $matric &&
                newData.child('course').val() === $courseId &&
                newData.child('date').val() === $date
              )",
            // ensure records include required fields and basic types
            ".validate": "newData.hasChildren(['name','matric','course','date','time','createdAt']) &&
                          newData.child('name').isString() &&
                          newData.child('matric').isString() &&
                          newData.child('course').isString() &&
                          newData.child('date').isString() &&
                          newData.child('time').isString() &&
                          newData.child('createdAt').isNumber()"
          }
        }
      }
    },

    "students": {
      // Students can only read their own data
      "$studentId": {
        ".read": "auth != null && auth.uid === $studentId",
        ".write": "auth != null && auth.uid === $studentId",
        ".validate": "newData.hasChildren(['name','matric','createdAt']) &&
                      newData.child('name').isString() &&
                      newData.child('matric').isString() &&
                      newData.child('createdAt').isNumber()"
      }
    },

    "lecturer_pin": {
      // Current lecturer PIN (single record)
      ".read": "auth != null",
      ".write": "auth != null && auth.token.admin === true",
      ".validate": "newData.hasChildren(['pin','updatedAt']) &&
                    newData.child('pin').isString() &&
                    newData.child('updatedAt').isNumber()"
    },

    "records": {
      // Legacy structure for backward compatibility
      ".read": "auth != null",
      ".write": "auth != null && auth.token.admin === true"
    }
  }
}